---
title: EDA-1 Tidy Data 
date: 2026-02-04 16:00:00 +0900
categories: [EDA]
tags: [EDA, DA, DS, statistics]     # TAG는 반드시 소문자로 작성하세요
---
# UNIT 2.

![1.png](/assets/img/unit-2/1.png)

## 1️⃣ 전체 개요

이 프로세스는 데이터를 다루는 전형적인 흐름을 보여준다.

> Import → Tidy → Transform → Visualise → Model → Communicate
> 

이 과정을 통해 데이터 과학자는 원시(raw) 데이터를 정제하고, 분석 가능한 형태로 만들고, 분석 결과를 시각화 및 전달하게 된다.

## 2️⃣ Tidy 단계

**Tidy(정돈하기)** 는 데이터를 일정한 규칙에 따라 구조화하는 과정이다.

여기서 중요한 원칙은 “tidy data” 규칙이다:

- **각 column은 하나의 변수(variable)**
    
    → 예: `age`, `income`, `gender` 등
    
- **각 row는 하나의 관측값(observation)**
    
    → 예: 한 사람, 한 실험 결과, 한 거래 등
    

즉, 데이터셋이 표 형태로 정리되어 분석에 바로 활용할 수 있도록 만드는 과정이다.

## 3️⃣ Transform 단계

**Transform(변환하기)** 는 데이터를 분석 목적에 맞게 다듬는 단계이다.

- 특정 관측값만 선택하거나
- 새로운 변수를 기존 변수로부터 계산하거나
- 요약 통계량(mean, median, sd 등)을 구하는 등의 작업이 포함된다.

이 단계는 데이터를 "이해하기 위한 형태"로 좁혀가는 핵심적인 과정이다.

## 4️⃣ Wrangling (Tidy + Transform)

정리(tidy)와 변환(transform) 과정을 함께 **데이터 전처리(data wrangling)** 라고 부른다.

이는 분석 전 반드시 수행되는 기초 작업으로, 전체 데이터 과학 과정의 70~80%를 차지할 정도로 중요하다.

## 5️⃣ Visualization & Modeling

데이터를 시각화하고, 통계적 모델이나 머신러닝 모델을 적용하여 지식을 생성하는 단계이다.

- **Visualization(시각화)** : 패턴, 관계, 이상치를 탐색
- **Modeling(모델링)** : 예측 및 인과 관계 추론

이 두 단계가 실제로 “지식을 생성하는 엔진” 역할을 한다.

## 6️⃣ Communicate

마지막으로 분석 결과를 이해관계자(팀, 고객, 보고서 독자 등)에게 명확히 전달하는 단계이다.

그래프, 보고서, 프레젠테이션 등이 여기에 포함된다.

| 단계 | 주요 내용 | 목적 |
| --- | --- | --- |
| **Import** | 데이터 불러오기 | 원천 데이터 확보 |
| **Tidy** | 정돈된 구조로 변환 | 분석 가능 형태로 정리 |
| **Transform** | 변수 생성·요약 | 분석 목적에 맞게 조정 |
| **Visualise / Model** | 탐색·예측 수행 | 지식 생성 |
| **Communicate** | 결과 전달 | 의사결정 지원 |

## 🧩 Pipes

### 1. Pipes란 무엇인가?

**Pipe(파이프)** 는 여러 연산을 **순서대로 명확하게 표현할 수 있는 도구**이다.

즉, 한 함수의 결과를 다음 함수의 입력으로 "파이프를 통해" 전달해주는 역할을 한다.

> 쉽게 말하면:
> 
> 
> **“이 함수의 결과를 다음 함수에 그대로 넘겨줘!”** 라는 의미이다.
> 

### 🧠 2. 두 가지 형태의 Pipe

- `|>` : R 4.1.0 버전 이후 기본 제공되는 **네이티브 파이프 연산자**
- `%>%` : `magrittr` 패키지에서 제공되는 **기존 파이프 연산자**

두 연산자의 기능은 거의 동일하지만,

`|>` 는 **기본 R**에 내장되어 있어서 추가 패키지 설치 없이 사용 가능하다.

### 💡 3. 왜 파이프를 쓰는가?

파이프를 사용하면 코드를 **더 읽기 쉽고 논리적인 순서로** 작성할 수 있다.

중첩 함수 호출을 줄여서, 위에서 아래로 데이터를 흘려보내듯이 표현할 수 있다.

예를 들어,

```
mean(head(seq(0.5, 11, by = 1)))

```

이 코드는 `seq()` → `head()` → `mean()` 순으로 처리된다.

하지만 괄호가 많아서 **읽기 불편**하다.

### 🔄 4. Pipe 사용법

파이프를 사용하면 위 코드를 다음처럼 바꿀 수 있다:

```
seq(0.5, 11, by = 1) |> head() |> mean()

```

즉,

1. `seq(0.5, 11, by = 1)`로 숫자열 생성
2. `head()`로 앞부분 일부 추출
3. `mean()`으로 평균 계산

이렇게 “데이터 흐름”이 왼쪽에서 오른쪽으로 **자연스럽게 이어지는 구조**가 된다.

### 📊 6. 예시 실행 결과 해석

```
> mean(head(seq(.5, 11, by = 1)))
[1] 3

> seq(.5, 11, by = 1) |> head() |> mean()
[1] 3

```

두 코드 모두 같은 결과 `[1] 3`을 출력한다.

다만 두 번째는 **가독성이 훨씬 높고**,

**분석 과정의 순서를 한눈에 이해**할 수 있다.

## 🦠Example 1: Tuberculosis data

## 🧩 1️⃣ 공통점

세 데이터셋 모두 **같은 정보**를 담고 있다:

- 변수: `country`, `year`, `population`, `cases`
- 즉, 각 나라의 특정 연도별 인구수와 결핵 환자 수를 나타낸다.

하지만 **구조(structure)** 가 다르다.

→ 이 구조 차이가 바로 “데이터를 얼마나 쉽게 다룰 수 있는가?”를 결정한다.

## 📊 Table 1 — **Wide Format (넓은 형식)**

| country | year | cases | population |
| --- | --- | --- | --- |
| Afghanistan | 1999 | 745 | 19987071 |
| Afghanistan | 2000 | 2666 | 20595360 |
| Brazil | 1999 | 37737 | 172006362 |
| ... | ... | ... | ... |

**특징**

- 각 변수(`cases`, `population`)가 **별도의 열(column)** 로 존재한다.
- 각 행(row)은 **한 관측 단위(나라+연도)** 를 나타낸다.

**장점**

- **tidy data 구조**이다!
    
    → 각 변수는 하나의 열, 각 관측값은 하나의 행, 각 값은 하나의 셀.
    
- 분석·시각화·모델링 등 모든 R 함수에서 바로 사용 가능.

**예시**

```
table1 |> mutate(rate = cases / population * 100000)

```

👉 이런 식으로 바로 계산 가능.

## 📈 Table 2 — **Long Format (길게 녹인 형식)**

| country | year | type | count |
| --- | --- | --- | --- |
| Afghanistan | 1999 | cases | 745 |
| Afghanistan | 1999 | population | 19987071 |
| Afghanistan | 2000 | cases | 2666 |
| ... | ... | ... | ... |

**특징**

- `cases`와 `population`이 하나의 열(`type`) 안에 녹아 있다.
- `count` 열에 값이 들어 있음.

**장점**

- **`pivot_wider()` 함수로 쉽게 wide 형식으로 복원** 가능.
- 여러 측정 단위를 하나의 열에 모아 비교 분석할 때 유용함.

**단점**

- 수식 계산 시 불편함 (예: `cases / population` 직접 계산 불가).
- 분석 전 `pivot_wider()`로 형태를 바꿔야 함.

**예시**

```
table2 |> pivot_wider(names_from = type, values_from = count)

```

## 🧮 Table 3 — **Untidy Format (비정돈형)**

| country | year | rate |
| --- | --- | --- |
| Afghanistan | 1999 | 745/19987071 |
| Afghanistan | 2000 | 2666/20595360 |
| Brazil | 1999 | 37737/172006362 |
| ... | ... | ... |

**특징**

- `rate`에 두 개의 값(`cases`와 `population`)이 합쳐져 **문자열 형태로 저장**되어 있음.

**문제점**

- **계산 불가능** (R이 문자열을 숫자로 인식하지 않음)
- `mutate()`, `summarise()` 같은 연산 수행이 **불가능함**.
- 데이터를 다시 분리(`separate()`)해야 함.

```
table3 |> separate(rate, into = c("cases", "population"), sep = "/")

```

---

## ✅ Which one is easiest to use?

| 비교 항목 | Table 1 | Table 2 | Table 3 |
| --- | --- | --- | --- |
| 구조 형태 | Tidy (wide) | Long (semi-tidy) | Untidy |
| 분석 편의성 | ✅ 가장 쉽다 | ⚠ 변환 필요 | ❌ 사용 어려움 |
| 추가 전처리 필요 여부 | 거의 없음 | `pivot_wider()` 필요 | `separate()` 필요 |
| R tidyverse 호환성 | 완벽 | 변환 후 가능 | 낮음 |

👉 **정답: `table1`이 가장 쉽고 이상적인 형식이다.**

이유는 tidy data 원칙을 충실히 따르기 때문:

> 각 변수는 열로, 각 관측은 행으로, 각 값은 셀로.
> 

![6.png](/assets/img/unit-2/6.png)

## 🧩 A dataset becomes tidy when …

즉, **데이터가 “tidy”하다는 것의 조건**을 설명하고 있다.

이건 **Hadley Wickham (R for Data Science 저자)** 가 제시한 **tidy data의 3원칙**이다.

| 원칙 | 설명 |
| --- | --- |
| **1. Each variable is a column** | 각 변수는 하나의 열로 표현된다. 예: `country`, `year`, `cases`, `population` |
| **2. Each observation is a row** | 각 관측값은 하나의 행으로 표현된다. 예: `Afghanistan, 1999` 한 행이 하나의 관측값 |
| **3. Each value is a cell** | 각 값은 하나의 셀에 존재한다. 즉, 한 셀에는 여러 값이 들어 있으면 안 됨 (예: `"745/19987071"` ❌) |

> 💡즉, tidy data = 분석에 바로 쓸 수 있는 “정돈된 표 형태 데이터”
> 
> 
> → ***“하나의 셀에 하나의 값, 하나의 변수에 하나의 열, 하나의 관측에 하나의 행”***
> 

## ⚙️ Main advantages of working with tidy data

tidy data를 사용하면 얻을 수 있는 **실질적인 이점**

### ✅ (1) Consistent structure → Easy learning

- 데이터 구조가 일관적이기 때문에
    
    → 새로운 도구(`dplyr`, `ggplot2`, `tidyr` 등)를 배울 때 훨씬 쉬움.
    
- 모든 패키지가 같은 규칙을 따르므로, 한 번 배워두면 어디서나 적용 가능.

---

### ✅ (2) Vectorized computation (R의 핵심 강점)

- R은 **“벡터(vector)” 기반 언어**이므로,
    
    열(column) 단위로 변수가 정리되어 있으면 빠른 연산 가능.
    
- 예를 들어 `mutate(rate = cases / population)` 이런 계산이 바로 가능하다.

> 🧠 “변수가 열로 배치될수록 R의 성능이 빛난다”는 뜻.
> 

---

### ✅ (3) Transformation becomes natural

- 정돈된 구조에서는 `filter()`, `group_by()`, `summarise()`, `mutate()` 같은 함수들을
    
    직관적·논리적 순서로 적용 가능.
    
- 즉, **데이터 변환이 자연스럽고 간단해진다.**

## 🦠Example 2: Tuberculosis data **`pivot_longer()`**

## 🧩 1️⃣ 데이터 설명

여기엔 두 개의 데이터셋이 있어:

### `table4a`

- **결핵(TB) 발생 건수(cases)** 를 보여주는 표
- 열 이름이 `1999`, `2000`처럼 **연도(year)** 로 되어 있음

| country | 1999 | 2000 |
| --- | --- | --- |
| Afghanistan | 745 | 2666 |
| Brazil | 37737 | 80488 |
| China | 212258 | 213766 |

---

### `table4b`

- **인구수(population)** 를 보여주는 표
- 구조는 동일하지만 값이 인구 수로 채워져 있음

| country | 1999 | 2000 |
| --- | --- | --- |
| Afghanistan | 19987071 | 20595360 |
| Brazil | 172006362 | 174504898 |
| China | 1272915272 | 1280428583 |

---

## ⚠️ 2️⃣ 문제점 (Problem)

> “Some of the column names are not names of variables, but values of a variable.”
> 

즉,

`1999`, `2000`은 **변수명(column name)** 이 아니라,

사실상 **연도(year)** 라는 변수의 **값(value)** 이어야 한다.

따라서 이 데이터는 **tidy data 원칙을 어긴 상태**이다.

---

## 🔧 3️⃣ 해결 방법 (How to solve)

이 문제는 **`pivot_longer()`** 함수를 사용해서

열(column)으로 되어 있는 연도들을 **행(row)** 으로 녹여내면 해결된다.

---

### ✅ 예시 코드

```r
table4a_tidy <- table4a |>
  pivot_longer(cols = c(`1999`, `2000`),
               names_to = "year",
               values_to = "cases")

table4b_tidy <- table4b |>
  pivot_longer(cols = c(`1999`, `2000`),
               names_to = "year",
               values_to = "population")
 
# 두 데이터 병합 (join)
tb_tidy <- left_join(table4a_tidy, table4b_tidy,
                     by = c("country", "year"))        
```

---

### ✅ 변환 결과 (tidy form)

| country | year | cases |
| --- | --- | --- |
| Afghanistan | 1999 | 745 |
| Afghanistan | 2000 | 2666 |
| Brazil | 1999 | 37737 |
| Brazil | 2000 | 80488 |
| China | 1999 | 212258 |
| China | 2000 | 213766 |

| country | year | population |
| --- | --- | --- |
| Afghanistan | 1999 | 19987071 |
| Afghanistan | 2000 | 20595360 |
| Brazil | 1999 | 172006362 |
| Brazil | 2000 | 174504898 |
| China | 1999 | 1272915272 |
| China | 2000 | 1280428583 |

| country | year | cases | population |
| --- | --- | --- | --- |
| Afghanistan | 1999 | 745 | 19987071 |
| Afghanistan | 2000 | 2666 | 20595360 |
| Brazil | 1999 | 37737 | 172006362 |
| Brazil | 2000 | 80488 | 174504898 |
| China | 1999 | 212258 | 1272915272 |
| China | 2000 | 213766 | 1280428583 |

---

## 🧠 4️⃣ 개념 정리

| 개념 | 설명 |
| --- | --- |
| **문제** | 열 이름(`1999`, `2000`)이 실제 변수값 |
| **해결** | `pivot_longer()`로 열 이름을 녹여서 변수(`year`)로 변환 |
| **결과** | tidy data 구조 (각 변수=열, 각 관측=행, 각 값=셀) |
| **다음 단계** | `left_join()` 으로 `cases`와 `population` 테이블 결합 가능 |

## 🦠Example 3: Tuberculosis data **`pivot_wider()`**

## 🧩 1️⃣ 데이터 개요 — `table2`

| country | year | type | count |
| --- | --- | --- | --- |
| Afghanistan | 1999 | cases | 745 |
| Afghanistan | 1999 | population | 19987071 |
| Afghanistan | 2000 | cases | 2666 |
| Afghanistan | 2000 | population | 20595360 |
| Brazil | 1999 | cases | 37737 |
| ... | ... | ... | ... |

## ⚠️ 2️⃣ 문제점 (Problem)

> “An observation is scattered across multiple rows.”
> 

즉,

하나의 관측값(예: 아프가니스탄 1999년)은 **두 줄로 나뉘어 있음.**

- 1행: 결핵 환자 수 (`cases`)
- 2행: 인구 수 (`population`)

**이렇게 하나의 관측 단위(국가+연도)가 여러 행에 흩어져 있으면**

**tidy 원칙(“각 행은 하나의 관측”)에 어긋나.**

## ⚙️ 3️⃣ 해결책 — `pivot_wider()`

이때는 반대로 열을 늘려서 “wide format”으로 되돌리는 작업이 필요해.

즉, `type` 열에 있는 값(`cases`, `population`)을 각각의 열 이름으로 만들고,

그에 대응하는 수치(`count`)를 값으로 채운다.

---

### ✅ 코드 예시

```
table2 |>
  pivot_wider(
    names_from = type,
    values_from = count
  )
```

---

### ✅ 결과 (tidy data 완성)

| country | year | cases | population |
| --- | --- | --- | --- |
| Afghanistan | 1999 | 745 | 19987071 |
| Afghanistan | 2000 | 2666 | 20595360 |
| Brazil | 1999 | 37737 | 172006362 |
| Brazil | 2000 | 80488 | 174504898 |
| China | 1999 | 212258 | 1272915272 |
| China | 2000 | 213766 | 1280428583 |

---

## 🧠 4️⃣ `pivot_wider()` 의 핵심 파라미터 두 가지

| 인자 | 설명 | 예시 |
| --- | --- | --- |
| `names_from` | 새 열 이름이 될 변수 | `type` (→ `cases`, `population`) |
| `values_from` | 셀에 채워질 값 | `count` |

---

## ✅ 5️⃣ 변환 요약

| 단계 | 형태 | 함수 | 특징 |
| --- | --- | --- | --- |
| **Before** | Long format (하나의 관측이 여러 행) | — | `cases` / `population`이 같은 변수에 있음 |
| **After** | Wide & Tidy | `pivot_wider()` | 각 변수별 열로 정리됨 (`cases`, `population`) |

---

## 💡 6️⃣ 핵심 포인트 요약

- `pivot_longer()` ↔ `pivot_wider()` 는 **서로 반대 연산**
- 둘 다 **tidyverse의 tidyr 패키지** 함수
- tidy data의 핵심 목표는
    
    > "각 행은 하나의 관측, 각 열은 하나의 변수, 각 셀은 하나의 값"
    > 

---

👉 **즉, table2는 “길게(long)” 되어 있어서 하나의 관측이 여러 행에 흩어져 있었고,`pivot_wider()`를 사용해 이를 “넓게(wide)” 정리함으로써 tidy data를 완성했다.**

## ☘️ THREE TYPES of DATASET - about TIBBLE

| 형태 | 특징 | 예시 |
| --- | --- | --- |
| **Matrix (행렬)** | 모든 원소가 **같은 타입**이어야 함 (예: 전부 numeric, 전부 character) | `matrix(1:6, nrow=2)` |
| **Data Frame** | 각 열이 **서로 다른 타입**을 가질 수 있음 (예: 문자, 숫자 혼합 가능) | `data.frame(name, age, gender)` |
| **Tibble** | Data Frame과 비슷하지만, **tidyverse 친화적**이고 동작이 더 일관적 | `tibble(name, age, gender)` |

👉 즉, `matrix`는 수학적 계산에 적합하고,

`data.frame`은 통계 데이터용,

`tibble`은 modern R (tidyverse)에서 가장 많이 쓰이는 형태야.

---

## 💡 Tibble이 Data Frame보다 나은 이유

![2.png](/assets/img/unit-2/2.png)

### ✅ (1) 변수 이름을 임의로 바꾸지 않음

- `data.frame()`은 공백이 있는 변수명 `"b 2"`을 자동으로 `"b.2"`로 바꾼다.
- `tibble()`은 원래 이름 `"b 2"` 그대로 유지한다.
    
    → **원본 데이터 구조 보존!**
    

```
df  <- data.frame("a" = 1:5, "b 2" = 5:1)
ti  <- tibble("a" = 1:5, "b 2" = 5:1)
```

| 타입 | 실제 열 이름 |
| --- | --- |
| data.frame | `"a"`, `"b.2"` |
| tibble | `"a"`, `"b 2"` |

---

### ✅ (2) 존재하지 않는 변수를 요청하면 “경고 메시지”를 준다

- `data.frame`은 존재하지 않는 열을 요청하면 그냥 `NULL` 반환
- `tibble`은 “존재하지 않는 변수입니다”라는 **명시적 경고(warning)** 표시

```
df$c   # NULL
ti$c   # Warning: Unknown or uninitialised column: `c`

```

> 즉, tibble은 “조용히 실패하지 않는다.”
> 
> 
> → 데이터 품질을 더 안전하게 유지할 수 있음.
> 

---

### ✅ (3) Subsetting(부분 추출)이 일관적이다

- `data.frame`은 `[ , ]` 사용 시, 결과가 **벡터(vector)** 나 **data frame** 둘 다 될 수 있음 (혼란)
- `tibble`은 항상 **tibble 형태로 반환**
    
    → 예측 가능한 결과를 제공함
    

```
df[, 1]  # vector 반환
ti[, 1]  # tibble 반환
```

---

### ✅ (4) 출력(Printing)이 깔끔하다

- tibble은 콘솔에 출력할 때 **몇 행, 몇 열만 깔끔하게 보여줌**
- 데이터가 커도 전체를 다 표시하지 않음 (data.frame은 화면 꽉 채움)

```
# tibble은 자동으로 preview 형태로 출력
ti
# A tibble: 5 × 2
#     a  `b 2`
#  <int> <int>
#  1     5
#  2     4
#  ...

```

---

## 📊 3️⃣ 예제 비교 요약 (슬라이드 코드 해설)

| 코드 | 결과 | 설명 |
| --- | --- | --- |
| `df = data.frame("a"=1:5, "b 2"=5:1)` | 열 이름이 `b.2`로 변경 | data.frame은 자동으로 변수명 수정 |
| `ti = tibble("a"=1:5, "b 2"=5:1)` | 열 이름이 `b 2` 그대로 | tibble은 원본 이름 유지 |
| `df$b` | 벡터 출력 (5 4 3 2 1) | `b.2`로 바뀌었지만 부분 매칭 허용 |
| `ti$b` | `NULL` + Warning | 부분 매칭 안 함, 더 안전 |
| `df[,1]` | 벡터 | data.frame은 타입이 불안정 |
| `ti[,1]` | tibble (5×1) | 일관된 형식 유지 |

---

## ✅ 정리 요약

| 구분 | **data.frame** | **tibble** |
| --- | --- | --- |
| 변수 이름 자동 변경 | O (공백, 특수문자 수정) | ❌ 원본 유지 |
| 존재하지 않는 변수 요청 시 | `NULL` 반환 (조용히 실패) | ⚠️ 경고 메시지 출력 |
| 부분 매칭(partial matching) | 허용 | ❌ 허용하지 않음 |
| 인덱싱 결과 타입 | 불안정 (벡터/DF 혼용) | 항상 tibble |
| 출력 방식 | 전체 출력 | 깔끔하게 일부만 표시 |
| tidyverse 호환성 | 낮음 | 매우 높음 |

---

👉 **결론:**

> “Tibble은 modern R (tidyverse) 환경에서 Data Frame을 대체하는,
> 
> 
> 더 일관적이고 안전한 데이터 구조이다.”
> 

## ⚙️ TIDYVERSE 함수들

## 🧹 1️⃣ For data tidying (데이터 정돈)

### **`separate()`**

> 하나의 열(column)에 여러 정보가 섞여 있을 때, 그것을 여러 열로 분리하는 함수
> 

예시:

```
df <- tibble(date = c("2025-10-12", "2025-10-13"))
df |> separate(date, into = c("year", "month", "day"), sep = "-")

```

➡ 결과

| year | month | day |
| --- | --- | --- |
| 2025 | 10 | 12 |
| 2025 | 10 | 13 |

즉, “하나의 열에 여러 의미가 들어 있는 경우” → `separate()`로 **분리해서 tidy하게** 만든다.

---

## 🔧 2️⃣ For data transformation (데이터 변환)

데이터를 **정리된 형태로 가공하거나 요약하는 단계**에서 사용하는 주요 함수들이야.

전부 `dplyr` 패키지에 포함되어 있어.

---

### **`filter()`**

> 특정 조건을 만족하는 행(row)만 선택
> 

예시:

```
df |> filter(year == 2025)

```

➡ 조건에 맞는 행만 남김 (행 추출)

---

### **`select()`**

> 특정 열(column)만 선택 (즉, 변수 선택)
> 

예시:

```
df |> select(country, cases)

```

➡ 필요한 열만 남김 (열 추출)

---

### **`arrange()`**

> 행의 순서를 정렬
> 

예시:

```
df |> arrange(year, desc(cases))

```

➡ `year` 오름차순, `cases` 내림차순 정렬

---

### **`mutate()`**

> 기존 변수를 이용해 새로운 변수를 생성하거나 기존 변수를 수정
> 

예시:

```
df |> mutate(rate = cases / population * 100000)

```

➡ 새로운 변수 `rate` 추가

---

### **`summarise()`**

> 여러 값을 하나의 요약 통계로 줄이는 함수 (평균, 합계, 표준편차 등)
> 

예시:

```
df |> summarise(mean_cases = mean(cases, na.rm = TRUE))

```

➡ 데이터의 평균값만 남김

---

## 🧠 3️⃣ 함께 자주 쓰이는 구조: `group_by() + summarise()`

데이터를 그룹별로 요약할 때 함께 사용됨 👇

```
df |>
  group_by(country) |>
  summarise(mean_rate = mean(rate))

```

➡ 나라별 평균 결핵 발생률 계산

---

## ✅ 4️⃣ 요약표

| 함수 | 주요 역할 | 예시 키워드 |
| --- | --- | --- |
| **separate()** | 한 열을 여러 열로 나누기 | 데이터 정돈 |
| **filter()** | 조건으로 행 선택 | 행 추출 |
| **select()** | 열 이름으로 선택 | 열 추출 |
| **arrange()** | 행 순서 정렬 | 오름·내림차순 |
| **mutate()** | 새 변수 생성 / 기존 수정 | 파생 변수 |
| **summarise()** | 요약 통계 계산 | 평균, 합계 등 |
| **group_by()** | 그룹 단위로 계산 준비 | 분류 요약 |

---

👉 **정리하자면:**

> tidying 은 데이터 구조를 “정리”하는 것 (ex. separate, pivot),
> 
> 
> `transforming` 은 데이터를 “가공·요약”하는 것 (ex. filter, mutate, summarise).
> 
